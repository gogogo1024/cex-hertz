// Code generated by hertz generator.

package main

import (
	"context"
	"log"
	"os"
	"os/signal"
	"strconv"
	"syscall"
	"time"

	"github.com/cloudwego/hertz/pkg/app/middlewares/server/recovery"
	"github.com/cloudwego/hertz/pkg/app/server"
	"github.com/cloudwego/hertz/pkg/app/server/registry"
	"github.com/cloudwego/hertz/pkg/common/hlog"
	"github.com/cloudwego/hertz/pkg/common/utils"
	"github.com/gogogo1024/cex-hertz-backend/biz/dal"
	"github.com/gogogo1024/cex-hertz-backend/biz/handler"
	"github.com/gogogo1024/cex-hertz-backend/biz/service"
	"github.com/gogogo1024/cex-hertz-backend/biz/util"
	"github.com/gogogo1024/cex-hertz-backend/conf"
	"github.com/gogogo1024/cex-hertz-backend/middleware"
	cexserver "github.com/gogogo1024/cex-hertz-backend/server"
	consulapi "github.com/hashicorp/consul/api"
	"github.com/hertz-contrib/cors"
	"github.com/hertz-contrib/gzip"
	"github.com/hertz-contrib/logger/accesslog"
	"github.com/hertz-contrib/pprof"
	"github.com/hertz-contrib/registry/consul"
	"go.uber.org/zap/zapcore"
	"gopkg.in/natefinch/lumberjack.v2"
)

func main() {
	cfg := conf.GetConf()
	dal.Init()
	consulClient := initConsul(cfg)
	h := initHertzServer(cfg, consulClient)
	wsServer, pm, localAddr := initBusiness(cfg, h)
	defer h.Shutdown(context.Background())
	defer wsServer.Shutdown(context.Background())
	startBackgroundTasks(cfg, pm, consulClient, localAddr)
	registerMiddleware(h)
	registerRoutes(h)
	go h.Spin()
	go wsServer.Spin()
	waitForExit()
	service.ShutdownOrderKafkaWriter()
}
func initConsul(cfg *conf.Config) *consulapi.Client {
	config := consulapi.DefaultConfig()
	config.Address = cfg.Registry.RegistryAddress[0]
	consulClient, err := consulapi.NewClient(config)
	if err != nil {
		log.Fatal(err)
	}
	return consulClient
}

func initHertzServer(cfg *conf.Config, consulClient *consulapi.Client) *server.Hertz {
	r := consul.NewConsulRegister(consulClient)
	addr := cfg.Hertz.Address
	serviceName := cfg.Hertz.Service
	h := server.Default(
		server.WithHostPorts(addr),
		server.WithRegistry(r, &registry.Info{
			ServiceName: serviceName,
			Addr:        utils.NewNetAddr("tcp", addr),
			Weight:      10,
			Tags:        nil,
		}),
		server.WithExitWaitTime(10*time.Second),
	)
	h.OnShutdown = append(h.OnShutdown, func(ctx context.Context) {
		service.StopOrderKafkaConsumerWithTimeout(10 * time.Second)
	})
	return h
}

func initBusiness(cfg *conf.Config, h *server.Hertz) (*server.Hertz, *service.PartitionManager, string) {
	hsPort := cfg.Hertz.WsPort
	if len(hsPort) > 0 && hsPort[0] == ':' {
		hsPort = hsPort[1:]
	}
	service.InitKafkaWriter(cfg.Kafka.Brokers, cfg.Kafka.Topics["trade"])
	service.InitOrderKafkaWriter(cfg.Kafka.Topics["order"])
	service.RecoverCompensateOrders()
	service.StartOrderKafkaConsumer(cfg.Kafka.Topics["order"])
	consulAddrs := cfg.Registry.RegistryAddress
	matchPort := cfg.MatchEngine.MatchPort
	pm, err := service.NewPartitionManager(consulAddrs)
	if err != nil {
		hlog.Fatalf("初始化 PartitionManager 失败: %v", err)
	}
	if err := pm.LoadFromConsul(); err != nil {
		hlog.Fatalf("加载分区表失败: %v", err)
	}
	localIP := util.GetLocalIP()
	localAddr := localIP + ":" + strconv.Itoa(matchPort)
	wsServer := cexserver.NewWebSocketServer(":"+hsPort, pm, localAddr)
	broadcaster := func(symbol string, msg []byte) {
		cexserver.Broadcast(symbol, msg)
	}
	unicast := func(userID string, msg []byte) {
		cexserver.Unicast(userID, msg)
	}
	matchEngine := service.NewPartitionAwareMatchEngine(pm, localAddr, broadcaster, unicast)
	cexserver.InjectEngine(matchEngine)
	service.MatchResultPusher = cexserver.PushMatchResult
	return wsServer, pm, localAddr
}

func startBackgroundTasks(cfg *conf.Config, pm *service.PartitionManager, consulClient *consulapi.Client, localAddr string) {
	service.StartKlineCompensateTask(consulClient)
	metrics := &service.MockPartitionMetrics{} // TODO: 替换为真实采集实现
	autoScaler := service.NewPartitionAutoScaler(pm, metrics, time.Minute)
	go autoScaler.Run(context.Background())
}

func waitForExit() {
	quit := make(chan os.Signal, 1)
	signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
	<-quit
}

func registerMiddleware(h *server.Hertz) {

	hlog.SetLevel(conf.LogLevel())
	hlog.SetOutput(zapcore.AddSync(&lumberjack.Logger{
		Filename:   conf.GetConf().Hertz.LogFileName,
		MaxSize:    conf.GetConf().Hertz.LogMaxSize,
		MaxBackups: conf.GetConf().Hertz.LogMaxBackups,
		MaxAge:     conf.GetConf().Hertz.LogMaxAge,
	}))
	// pprof
	if conf.GetConf().Hertz.EnablePprof {
		pprof.Register(h)
	}

	// gzip
	if conf.GetConf().Hertz.EnableGzip {
		h.Use(gzip.Gzip(gzip.DefaultCompression))
	}

	// access log
	if conf.GetConf().Hertz.EnableAccessLog {
		h.Use(accesslog.New())
	}

	// recovery
	h.Use(recovery.Recovery())

	// cores
	h.Use(cors.Default())
	middleware.Register(h)
}

func registerRoutes(h *server.Hertz) {
	h.GET("/ping", handler.Ping)
	orderGroup := h.Group("/api")
	//orderGroup.Use(middleware.DistributedRouteMiddleware())
	orderGroup.POST("/order", handler.SubmitOrder)
	orderGroup.GET("/order/:id", handler.GetOrder)
	orderGroup.GET("/orders", handler.ListOrders)
	orderGroup.POST("/order/cancel", handler.CancelOrder)
	orderGroup.GET("/balance", handler.GetBalance)
	orderGroup.GET("/positions", handler.GetPositions)
	orderGroup.GET("/depth", handler.GetDepth)
	orderGroup.GET("/trades", handler.GetTrades)
	orderGroup.GET("/ticker", handler.GetTicker)
	orderGroup.GET("/kline", handler.GetKline)
}
