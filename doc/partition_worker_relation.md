# 分区（Partition）与 Worker（撮合引擎节点）关系说明

## 概念定义

- **分区（Partition）**：撮合系统中负责一组 symbol（交易对）撮合任务的逻辑单元。每个分区有自己的唯一 ID、负责的 symbol 列表（Symbols），以及分配给它的 worker 列表（Workers）。
- **Worker（撮合引擎节点）**：实际运行撮合引擎的服务实例（如进程或容器），负责处理分配给它的分区中的 symbol 的撮合请求。每个 worker 可以负责一个或多个分区。

## 对应关系

- 一个分区可以分配给一个或多个 worker（通常用于高可用、主备、负载均衡等场景）。
- 一个 worker 可以同时负责多个分区（提升资源利用率和弹性）。
- 分区和 worker 之间是多对多的灵活分配关系。

## 举例

- PartitionA：Symbols = [BTCUSDT, ETHUSDT]，Workers = [worker1]
- PartitionB：Symbols = [DOGEUSDT]，Workers = [worker2]
- worker1 负责 PartitionA，worker2 负责 PartitionB

## 设计优势

- 支持弹性扩缩容：可根据业务压力动态调整分区与 worker 的分配关系。
- 支持高可用：同一分区可分配给多个 worker，实现主备或多活。
- 支持负载均衡：新分区可优先分配给空闲 worker，提升整体资源利用率。

## 典型应用场景

- 热点 symbol 拆分：将高负载 symbol 独立为新分区，分配到新 worker。
- 冷门 symbol 合并：将低负载 symbol 合并到同一分区，减少资源浪费。
- 分区迁移：支持分区在 worker 之间灵活迁移，保证系统弹性和高可用。

## 分区扩缩容与消息处理（对标 Redis 迁移机制）

在分区（Partition）扩缩容、迁移过程中，系统需保证 symbol 的撮合消息不丢失、顺序性可控、业务不中断。参照 Redis 集群的数据迁移机制，撮合系统的消息处理建议如下：

### 1. 迁移阶段的多对多映射
- 分区扩缩容或迁移时，`SymbolToPartition` 支持 symbol 到多个分区的多对多映射。
- 迁移期间，同一个 symbol 可能同时属于旧分区和新分区，实现新旧分区并行。

### 2. 消息处理策略
- **新旧分区并行**：迁移开始后，symbol 的撮合请求可路由到新旧分区，或采用灰度切流、双写等方式，保证新分区补齐历史数据。
- **消息同步/补偿**：旧分区需将未完成订单、撮合消息同步到新分区，确保新分区数据完整。
- **顺序与幂等**：每条撮合消息应有唯一ID，分区间同步时可去重，顺序性可通过全局队列、分布式锁或业务容忍短暂乱序实现。
- **冻结-切换机制（更强顺序保障，可选）**：如需严格顺序保障，可在迁移时采用“冻结-同步-切换”机制：
    - 迁移前，先冻结旧分区对目标 symbol 的写入，仅允许读取和同步历史数据。
    - 新分区补齐历史数据后，切换 symbol 的所有写入流量到新分区，旧分区下线。
    - 该机制可避免新旧分区并发写同一symbol，彻底消除乱序风险，但迁移窗口内部分业务可能短暂不可写。
- **Redis式异步迁移与重定向**：可借鉴 Redis 集群 slot 迁移机制，迁移期间不冻结写操作，而是通过 symbol 路由表动态切换和请求重定向，让新旧分区都能处理该 symbol 的请求。数据通过异步同步和幂等性保障最终一致，业务几乎无感知。
- **异步缓冲+回放**：冻结期间，用户写操作先缓存在高可用队列，迁移完成后批量回放到新分区，用户仅感知轻微延迟。
- **双写+幂等**：迁移窗口内，写操作同时写入新旧分区，利用幂等性保证不会重复处理，迁移完成后只保留新分区。
- **只冻结部分写操作**：如只冻结新订单写入，撤单等高优先级操作仍允许，最大程度保障用户核心操作。
- **分批迁移/分时迁移**：将 symbol 拆分为多批次、分时段迁移，每次只冻结一小部分，降低整体影响。
- **业务降级/提示**：冻结期间对用户做友好提示，或临时降级为只读模式，提升用户体验预期管理。
- **迁移窗口选择业务低峰期**：在夜间或业务低峰时段进行迁移，减少对活跃用户的影响。
- **自动回滚/快速切换**：如迁移异常可自动回滚到旧分区，或支持秒级切换，缩短不可用时间。

### 2.1 Redis式异步迁移与重定向的实现建议
- **路由表动态切换**：在迁移期间，`SymbolToPartition` 路由表支持同一个 symbol 同时指向新旧分区。撮合请求到达时，先查路由表，决定路由到哪个分区。
- **请求重定向机制**：如果 symbol 的主分区已迁移，旧分区收到写请求时可返回重定向（如 HTTP 302/自定义错误码），客户端或上游服务自动重试到新分区。
- **异步数据同步**：旧分区在迁移期间将未完成订单、撮合消息异步同步到新分区。新分区补齐数据后可立即对外服务。
- **幂等与去重**：所有订单、撮合消息都带唯一ID（如 orderID），新旧分区并行期间通过幂等性和去重机制保证不会重复处理。
- **最终收敛**：迁移��成后，路由表只保留新分区，旧分区不再处理该 symbol。
- **乱序容忍与补偿**：极短乱序可通过业务幂等、补偿、对账等机制收敛。

### 2.2 伪代码示例
```go
// 路由表查找
func RouteOrder(symbol string) Partition {
    return SymbolToPartition[symbol] // 可能返回新旧分区列表
}

// 请求重定向
func HandleOrder(order) {
    p := RouteOrder(order.Symbol)
    if p.IsMigrating {
        // 旧分区收到写请求，重定向到新分区
        return RedirectToNewPartition(order)
    }
    // 正常处理
    ProcessOrder(order)
}

// 异步同步
func SyncUnfinishedOrders(oldPartition, newPartition) {
    for order in oldPartition.UnfinishedOrders {
        newPartition.ReplayOrder(order)
    }
}
```

### 3. 切流与收敛
- **灰度切流**：逐步将 symbol 的撮合流量切到新分区，旧分区只处理历史未完成订单。
- **最终收敛**：确认新分区已完全接管 symbol 后，`SymbolToPartition` 只保留新分区，旧分区下线。

### 4. 设计优势
- 支持平滑迁移、弹性扩缩容和高可用。
- 迁移期间业务不中断，消息无丢失。
- 便于实现主备、灰度、AB测试等复杂场景。

---

本机制借鉴了 Redis 等分布式系统的数据迁移原理，适用于高并发撮合系统的分区弹性和高可用设计。
