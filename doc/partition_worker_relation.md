# 撮合系统分区、Worker节点、撮合引擎与Symbol关系说明

## 概念定义

- **分区（Partition）**：撮合系统中用于管理和分配 symbol（交易对）的逻辑单元。分区本身不直接处理撮合，而是作为 symbol 的分组和分配管理单元，支撑弹性扩缩容、负载均衡和高可用。
- **Worker节点（Worker）**：实际运行撮合服务的进程或容器实例。每个 worker 节点负责分区分配给它的 symbol 集合，并为每个 symbol 启动一个撮合引擎实例。
- **撮合引擎实例（MatchEngine）**：每个 symbol 都有一个独立的撮合引擎实例（通常为一个 goroutine），负责该 symbol 的订单撮合、撮合算法和订单簿管理。
- **Symbol（交易对）**：具体的交易对（如 BTCUSDT、ETHUSDT），是撮合系统的最小撮合单元。

> 总结：分区是 symbol 的分组和分配管理单元，worker 节点负责分区的 symbol 集合，每个 symbol 由一个撮合引擎实例处理，实现高并发、弹性和高可用。

## 对应关系

- 一个分区可以分配给一个主worker和若干备worker（通常用于高可用、主备场景）。主worker负责撮合，备worker用于高可用切换。
- 多worker并发处理同一分区需有强一致性和冲突解决机制，否则不推荐在实际交易所场景下使用。
- 一个 worker 可以同时负责多个分区（提升资源利用率和弹性）。
- 分区和 worker 之间是多对多的灵活分配关系。

## 举例

- PartitionA：Symbols = [BTCUSDT, ETHUSDT]，Workers = [worker1]
- PartitionB：Symbols = [DOGEUSDT]，Workers = [worker2]
- worker1 负责 PartitionA，worker2 负责 PartitionB

## 设计优势

- 支持弹性扩缩容：可根据业务压力动态调整分区与 worker 的分配关系。
- 支持高可用：同一分区可分配给多个 worker，实现主备或多活。
- 支持负载均衡：新分区可优先分配给空闲 worker，提升整体资源利用率。

## 典型应用场景

- 热点 symbol 拆分：将高负载 symbol 独立为新分区，分配到新 worker。
- 冷门 symbol 合并：将低负载 symbol 合并到同一分区，减少资源浪费。
- 分区迁移：支持分区在 worker 之间灵活迁移，保证系统弹性和高可用。

## 分区扩缩容与消息处理（对标 Redis 迁移机制）

在分区（Partition）扩缩容、迁移过程中，系统需保证 symbol 的撮合消息不丢失、顺序性可控、业务不中断。参照 Redis 集群的数据迁移机制，撮合系统的消息处理建议如下：

### 1. 迁移阶段的多对多映射
- 分区扩缩容或迁移时，`SymbolToPartition` 支持 symbol 到多个分区的多对多映射。
- 迁移期间，同一个 symbol 可能同时属于旧分区和新分区，实现新旧分区并行。

### 2. 消息处理策略
- **新旧分区并行**：迁移开始后，symbol 的撮合请求可路由到新旧分区，或采用灰度切流、双写等方式，保证新分区补齐历史数据。
- **消息同步/补偿**：旧分区需将未完成订单、撮合消息同步到新分区，确保新分区数据完整。
- **顺序与幂等**：每条撮合消息应有唯一ID，分区间同步时可去重，顺序性可通过全局队列、分布式锁或业务容忍短暂乱序实现。
- **冻结-切换机制（更强顺序保障，可选）**：如需严格顺序保障，可在迁移时采用“冻结-同步-切换”机制：
    - 迁移前，先冻结旧分区对目标 symbol 的写入，仅允许读取和同步历史数据。
    - 新分区补齐历史数据后，切换 symbol 的所有写入流量到新分区，旧分区下线。
    - 该机制可避免新旧分区并发写同一symbol，彻底消除乱序风险，但迁移窗口内部分业务可能短暂不可写。
- **Redis式异步迁移与重定向**：可借鉴 Redis 集群 slot 迁移机制，迁移期间不冻结写操作，而是通过 symbol 路由表动态切换和请求重定向，让新旧分区都能处理该 symbol 的请求。数据通过异步同步和幂等性保障最终一致，业务几乎无感知。
- **异步缓冲+回放**：冻结期间，用户写操作先缓存在高可用队列，迁移完成后批量回放到新分区，用户仅感知轻微延迟。
- **双写+幂等**：迁移窗口内，写操作同时写入新旧分区，利用幂等性保证不会重复处理，迁移完成后只保留新分区。
- **只冻结部分写操作**：如只冻结新订单写入，撤单等高优先级操作仍允许，最大程度保障用户核心操作。
- **分批迁移/分时迁移**：将 symbol 拆分为多批次、分时段迁移，每次只冻结一小部分，降低整体影响。
- **业务降级/提示**：冻结期间对用户做友好提示，或临时降级为只读模式，提升用户体验预期管理。
- **迁移窗口选择业务低峰期**：在夜间或业务低峰时段进行迁移，减少对活跃用户的影响。
- **自动回滚/快速切换**：如迁移异常可自动回滚到旧分区，或支持秒级切换，缩短不可用时间。

### 2.1 Redis式异步迁移与重定向的实现建议
- **路由表动态切换**：在迁移期间，`SymbolToPartition` 路由表支持同一个 symbol 同时指向新旧分区。撮合请求到达时，先查路由表，决定路由到哪个分区。
- **请求重定向机制**：如果 symbol 的主分区已迁移，旧分区收到写请求时可返回重定向（如 HTTP 302/自定义错误码），客户端或上游服务自动重试到新分区。
- **异步数据同步**：旧分区在迁移期间将未完成订单、撮合消息异步同步到新分区。新分区补齐数据后可立即对外服务。
- **幂等与去重**：所有订单、撮合消息都带唯一ID（如 orderID），新旧分区并行期间通过幂等性和去重机制保证不会重复处理。
- **最终收敛**：迁移完成成后，路由表只保留新分区，旧分区不再处理该 symbol。
- **乱序容忍与补偿**：极短乱序可通过业务幂等、补偿、对账等机制收敛。

### 2.2 伪代码示例
```go
// 路由表查找
func RouteOrder(symbol string) Partition {
    return SymbolToPartition[symbol] // 可能返回新旧分区列表
}

// 请求重定向
func HandleOrder(order) {
    p := RouteOrder(order.Symbol)
    if p.IsMigrating {
        // 旧分区收到写请求，重定向到新分区
        return RedirectToNewPartition(order)
    }
    // 正常处理
    ProcessOrder(order)
}

// 异步同步
func SyncUnfinishedOrders(oldPartition, newPartition) {
    for order in oldPartition.UnfinishedOrders {
        newPartition.ReplayOrder(order)
    }
}
```

### 3. 切流与收敛
- **灰度切流**：逐步将 symbol 的撮合流量切到新分区，旧分区只处理历史未完成订单。
- **最终收敛**：确认新分区已完全接管 symbol 后，`SymbolToPartition` 只保留新分区，旧分区下线。

### 4. 设计优势
- 支持平滑迁移、弹性扩缩容和高可用。
- 迁移期间业务不中断，消息无丢失。
- 便于实现主备、灰度、AB测试等复杂场景。

---

本机制借鉴了 Redis 等分布式系统的数据迁移原理，适用于高并发撮合系统的分区弹性和高可用设计。

## Redis式异步迁移与重定向的实现建议

### 已实现机制
- 路由表动态切换：SymbolToPartition 路由表支持 symbol 到新旧分区的多对多映射。
- 异步数据同步：旧分区在迁移期间将未完成订单、撮合消息异步同步到新分区。
- 幂等与去重：所有订单、撮合消息都带唯一ID（如 orderID），新旧分区并行期间通过幂等性和去重机制保证不会重复处理。
- 最终收敛：迁移完成后，路由表只保留新分区，旧分区不再处理该 symbol。

### 待补充机制
- 请求重定向机制：旧分区收到写请求时，主动返回重定向信号（如自定义错误码），客户端自动重试到新分区。已在 biz/handler/migrate_redirect_handler.go 实现。
- 乱序容忍与补偿：极短乱序可通过业务幂等、补偿、对账等机制收敛。
- 迁移异常自动回滚/快速切换：如迁移异常可自动回滚到旧分区，或支持秒级切换，缩短不可用时间。

### 请求重定向机制代码入口
- 代码文件：biz/handler/migrate_redirect_handler.go
- 主要逻辑：旧分区收到 symbol 的写请求时，判断 symbol 是否已迁移，若已迁移则返回重定向响应（如自定义错误码），客户端可自动重试到新分区。

---

## DistributedRouteMiddleware 与请求重定向机制说明

### DistributedRouteMiddleware
- 作用：分布式撮合自动路由中间件。根据分区路由表动态判断 symbol 是否由本地 worker 负责。
- 实现方式：如果 symbol 不属于本地分区，则自动将请求转发（forward）到负责该 symbol 的其他撮合引擎节点（如 ForwardOrderToMatchEngine）。客户端无感知，服务端自动分发。
- 适用场景：分布式撮合系统的自动路由和请求分发，提升系统弹性和高可用。

### 请求重定向机制
- 作用：迁移期间，旧分区收到 symbol 的写请求时，主动返回重定向信号（如自定义错误码），提示客户端自动重试到新分区。
- 实现方式：服务端判断 symbol 是否已迁移，若已迁移则返回重定向响应（如 40901 错误码和新分区信息），客户端或上游服务自动重试到新分区。
- 适用场景：分区迁移期间，客户端自适应新旧分区切换，保障业务无缝迁移和最终一致性。

### 区别与联系
- DistributedRouteMiddleware 是服务端主动转发，客户端无感知。
- 请求重定向机制是服务端返回重定向提示，由客户端或上游服务自动重试到新分区。
- 两者都实现了“请求不由本地处理时的分发/重定向”，但实现方式和业务场景不同。

---

## Worker 节点与撮合引擎说明

- **Worker 节点**：实际运行撮合服务的进程或容器实例。每个 worker 节点可以负责一个或多个分区，处理分配给它的 symbol（交易对）的撮合请求。worker 节点通常具备独立的网络地址和资源，支持弹性扩缩容和高可用。

- **撮合引擎**：实现撮合逻辑的核心模块或服务，负责订单撮合、撮合算法、订单簿管理等。撮合引擎可以作为 worker 节点的核心组件，每个 worker 节点内部通常会运行一个或多个撮合引擎实例，专门处理分区内的撮合任务。

> 总结：worker 节点是物理或虚拟的服务实例，负责分区的撮合任务；撮合引擎是 worker 节点内部的撮合逻辑实现。分区与 worker 节点、撮合引擎之间通过灵活分配，实现高并发、弹性和高可用的撮合系统。

---

## 分区、Worker节点、撮合引擎实例、Symbol关系图

```
+-------------------+         +-------------------+
|   Partition A     |         |   Partition B     |
|  [BTCUSDT,ETHUSDT]|         |    [DOGEUSDT]     |
+-------------------+         +-------------------+
         |                            |
         |                            |
         v                            v
+-------------------+         +-------------------+
|   Worker Node 1   |         |   Worker Node 2   |
+-------------------+         +-------------------+
         |                            |
         |                            |
         v                            v
+-------------------+         +-------------------+
| MatchEngine(BTC)  |         | MatchEngine(DOGE) |
| MatchEngine(ETH)  |         +-------------------+
+-------------------+
```

- 分区A分配给Worker1，Worker1负责BTCUSDT和ETHUSDT，每个symbol有一个MatchEngine实例。
- 分区B分配给Worker2，Worker2负责DOGEUSDT，有一个MatchEngine实例。

说明：
- 分区是symbol的分组和分配管理单元。
- Worker节点负责分区的symbol集合。
- 每个symbol由一个撮合引擎实例（MatchEngine）处理。
- Worker节点实际运行的撮合引擎实例数量等于其负责的symbol数量。
